name: .NET (Windows + Pre-Build Utilities)

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      app_name:
        description: "New application name (letters only, e.g., MyNewApp)"
        required: false
        default: "MyNewApp"
      selections:
        description: "Comma-separated highest→lowest selections to remove (e.g., 6,5,4)"
        required: false
        default: "6,5,4,3,2,1"
      remove_delay_ms:
        description: "Delay in ms between removals"
        required: false
        default: "1000"

jobs:
  build:
    runs-on: windows-latest

    env:
      RENAME_EXE: '.\Rename FreeCRM.exe'
      REMOVE_EXE: '.\Remove Modules from FreeCRM.exe'
      APP_NAME: ${{ github.event.inputs.app_name }}
      SELECTIONS: ${{ github.event.inputs.selections }}
      REMOVE_DELAY_MS: ${{ github.event.inputs.remove_delay_ms }}

    steps:
      - uses: actions/checkout@v4

      # Install .NET SDKs (includes runtimes)
      - name: Setup .NET 9 & 8 SDKs
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            9.0.x
            8.0.x

      - name: Verify .NET
        shell: pwsh
        run: |
          dotnet --info
          dotnet --list-sdks

      # --- RENAME: run once, pipe the name, allow the final ReadKey to fail without stopping the job ---
      - name: Rename (pipe app name; ignore press-any-key failure)
        shell: pwsh
        continue-on-error: true
        run: |
          $exe = $env:RENAME_EXE
          if (-not (Test-Path $exe)) { throw "Rename EXE not found at: $exe" }

          $name = $env:APP_NAME
          if ([string]::IsNullOrWhiteSpace($name)) { $name = "MyNewApp" }

          # Validate: letters only (tool rejects spaces, periods, numbers)
          if ($name -notmatch '^[A-Za-z]+$') {
            throw "APP_NAME '$name' is invalid. Use letters only (e.g., MyNewApp)."
          }

          # Pipe name + newline to STDIN (the tool will do its work, then try ReadKey and exit non-zero)
          Set-Content -Path rename_input.txt -Value "$name`r`n" -NoNewline -Encoding ascii

          Write-Host "Running rename with app name: $name"
          & "$exe" < rename_input.txt
          $code = $LASTEXITCODE

          # Clean up and add a small delay to let file ops settle
          Remove-Item rename_input.txt -Force -ErrorAction SilentlyContinue
          Start-Sleep -Milliseconds 500

          if ($code -ne 0) {
            Write-Warning "Rename tool exited with code $code (expected on Actions due to ReadKey). Assuming rename already completed and continuing."
          }

      # --- REMOVE: run highest→lowest, piping input each time with a delay you control ---
      - name: Remove modules (highest → lowest) with STDIN + delay
        shell: pwsh
        run: |
          $exe = $env:REMOVE_EXE
          if (-not (Test-Path $exe)) { throw "Remove utility not found at: $exe" }

          $selections = if ([string]::IsNullOrWhiteSpace($env:SELECTIONS)) { "6,5,4,3,2,1" } else { $env:SELECTIONS }
          $delayMs = if ([string]::IsNullOrWhiteSpace($env:REMOVE_DELAY_MS)) { 1000 } else { [int]$env:REMOVE_DELAY_MS }

          $targets =
            $selections -split ',' |
            ForEach-Object { $_.Trim() } |
            Where-Object { $_ -match '^\d+$' } |
            ForEach-Object { [int]$_ } |
            Sort-Object -Descending

          if (-not $targets) { throw "No valid numeric selections in: '$selections'" }

          Write-Host "Selections to remove (highest→lowest): $($targets -join ', ')"
          Write-Host "Delay between removals: $delayMs ms"

          foreach ($n in $targets) {
            Write-Host "`n=== $exe with selection $n, then 'x' ==="

            # Build file content with CRLF: "<n>\r\nx\r\n"
            $inputText = "$n`r`nx`r`n"
            Set-Content -Path input.txt -Value $inputText -NoNewline -Encoding ascii

            & "$exe" < input.txt
            $exit = $LASTEXITCODE

            Remove-Item input.txt -Force -ErrorAction SilentlyContinue

            if ($exit -ne 0) {
              throw "Remove run failed for selection $n (exit $exit)"
            }

            Start-Sleep -Milliseconds $delayMs
          }

          Write-Host "`nAll removals completed."

      # --- Build/Test ---
      - name: Restore
        shell: pwsh
        run: dotnet restore

      - name: Build
        shell: pwsh
        run: dotnet build --no-restore

      - name: Test
        shell: pwsh
        run: dotnet test --no-build --verbosity normal
