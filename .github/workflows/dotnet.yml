name: .NET (Windows • remove via feeder • safe rename • build artifacts)

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      selections:
        description: "Comma-separated highest→lowest to remove (e.g., 6,5,4)"
        required: false
        default: "6,5,4,3,2,1"
      delay_ms:
        description: "Delay (ms) between lines sent to the apps"
        required: false
        default: "1000"
      app_name:
        description: "New application name for the rename tool (letters only, e.g., FreeCICD)"
        required: false
        default: "FreeCICD"

# Explicit permissions so workflow can push commits if needed
permissions:
  contents: write

jobs:
  #---------------------------------------------------------
  # Build the small StdIn feeder and upload it.
  #---------------------------------------------------------
  feeder:
    name: Build feeder
    runs-on: windows-latest

    steps:
      - name: Setup .NET SDK 8
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Create feeder project (with kill-on support)
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path tools\StdInFeeder | Out-Null

          $code = @'
          using System;
          using System.Diagnostics;
          using System.IO;
          using System.Text;
          using System.Threading.Tasks;

          class Program
          {
              static int Main(string[] args)
              {
                  string exe = null;
                  string inputPath = null;
                  int delay = 500;

                  string killOn = null;
                  int killDelay = 200;
                  bool killTriggered = false;

                  for (int i = 0; i < args.Length; i++)
                  {
                      switch (args[i])
                      {
                          case "--exe":        exe = args[++i]; break;
                          case "--input":      inputPath = args[++i]; break;
                          case "--delay":      delay = int.Parse(args[++i]); break;
                          case "--kill-on":    killOn = args[++i]; break;
                          case "--kill-delay": killDelay = int.Parse(args[++i]); break;
                      }
                  }

                  if (string.IsNullOrWhiteSpace(exe) || !File.Exists(exe))
                  {
                      Console.Error.WriteLine($"Target exe not found: {exe}");
                      return 2;
                  }
                  if (string.IsNullOrWhiteSpace(inputPath) || !File.Exists(inputPath))
                  {
                      Console.Error.WriteLine($"Input file not found: {inputPath}");
                      return 3;
                  }

                  var psi = new ProcessStartInfo
                  {
                      FileName = exe,
                      UseShellExecute = false,
                      RedirectStandardInput = true,
                      RedirectStandardOutput = true,
                      RedirectStandardError = true,
                      CreateNoWindow = true
                  };

                  using var p = new Process { StartInfo = psi };

                  p.OutputDataReceived += (_, e) =>
                  {
                      if (e.Data != null)
                      {
                          Console.WriteLine(e.Data);
                          if (!string.IsNullOrEmpty(killOn) &&
                              e.Data.IndexOf(killOn, StringComparison.OrdinalIgnoreCase) >= 0 &&
                              !killTriggered)
                          {
                              killTriggered = true;
                              _ = Task.Run(() =>
                              {
                                  try
                                  {
                                      System.Threading.Thread.Sleep(killDelay);
                                      if (!p.HasExited)
                                      {
                                          try { p.CloseMainWindow(); } catch { }
                                          if (!p.HasExited) p.Kill(true);
                                      }
                                  }
                                  catch { }
                              });
                          }
                      }
                  };
                  p.ErrorDataReceived += (_, e) => { if (e.Data != null) Console.Error.WriteLine(e.Data); };

                  if (!p.Start()) return 4;
                  p.BeginOutputReadLine();
                  p.BeginErrorReadLine();

                  foreach (var line in File.ReadAllLines(inputPath, Encoding.ASCII))
                  {
                      p.StandardInput.WriteLine(line);
                      p.StandardInput.Flush();
                      System.Threading.Thread.Sleep(delay);
                  }
                  p.StandardInput.Close();

                  p.WaitForExit();

                  return killTriggered ? 0 : p.ExitCode;
              }
          }
          '@
          Set-Content -Path tools\StdInFeeder\Program.cs -Value $code -Encoding UTF8

          $proj = @'
          <Project Sdk="Microsoft.NET.Sdk">
            <PropertyGroup>
              <OutputType>Exe</OutputType>
              <TargetFramework>net8.0</TargetFramework>
              <PublishSingleFile>true</PublishSingleFile>
              <RuntimeIdentifier>win-x64</RuntimeIdentifier>
              <SelfContained>false</SelfContained>
            </PropertyGroup>
          </Project>
          '@
          Set-Content -Path tools\StdInFeeder\StdInFeeder.csproj -Value $proj -Encoding UTF8

      - name: Publish feeder
        shell: pwsh
        run: |
          dotnet publish tools\StdInFeeder -c Release -o tools\StdInFeeder\out
          Get-ChildItem tools\StdInFeeder\out

      - name: Upload feeder artifact
        uses: actions/upload-artifact@v4
        with:
          name: stdin_feeder
          path: tools/StdInFeeder/out

  #---------------------------------------------------------
  # Main job: checkout, run removal & rename, build/test,
  # collect artifacts (no dotnet publish).
  #---------------------------------------------------------
  build:
    name: Build & snapshot
    runs-on: windows-latest
    needs: feeder

    env:
      REMOVE_EXE: '.\Remove Modules from FreeCRM.exe'
      RENAME_EXE: '.\Rename FreeCRM.exe'
      FEEDER_EXE: '.\tools\StdInFeeder\out\StdInFeeder.exe'
      SELECTIONS: ${{ github.event.inputs.selections }}
      DELAY_MS:  ${{ github.event.inputs.delay_ms }}
      APP_NAME:  ${{ github.event.inputs.app_name }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET 9 & 8 SDKs
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            9.0.x
            8.0.x

      - name: Download feeder artifact
        uses: actions/download-artifact@v4
        with:
          name: stdin_feeder
          path: tools/StdInFeeder/out

      - name: Verify feeder exists
        shell: pwsh
        run: |
          if (-not (Test-Path $env:FEEDER_EXE)) { throw "Feeder EXE not found at $env:FEEDER_EXE" }
          Get-Item $env:FEEDER_EXE | Format-List *

      - name: Remove modules using feeder
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $exe = $env:REMOVE_EXE
          if (-not (Test-Path $exe)) { throw "Remove utility not found at: $exe" }

          $selections = if ([string]::IsNullOrWhiteSpace($env:SELECTIONS)) { "6,5,4,3,2,1" } else { $env:SELECTIONS }
          $delayMs    = if ([string]::IsNullOrWhiteSpace($env:DELAY_MS)) { 1000 } else { [int]$env:DELAY_MS }

          $targets =
            $selections -split ',' |
            ForEach-Object { $_.Trim() } |
            Where-Object { $_ -match '^\d+$' } |
            ForEach-Object { [int]$_ } |
            Sort-Object -Descending

          foreach ($n in $targets) {
            Write-Host "`n=== $exe with selection $n, then 'x' ==="
            Set-Content -Path input.txt -Value @("$n","x") -Encoding ASCII
            & $env:FEEDER_EXE --exe "$exe" --input "input.txt" --delay $delayMs
            if ($LASTEXITCODE -ne 0) { throw "Remove run failed for selection $n (exit $LASTEXITCODE)" }
            Remove-Item input.txt -Force -ErrorAction SilentlyContinue
          }

      - name: Rename project using feeder (safe for CI)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $exe  = $env:RENAME_EXE
          if (-not (Test-Path $exe)) { throw "Rename utility not found at: $exe" }

          $name = if ([string]::IsNullOrWhiteSpace($env:APP_NAME)) { "FreeCICD" } else { $env:APP_NAME }
          if ($name -notmatch '^[A-Za-z]+$') { throw "APP_NAME '$name' is invalid." }

          Set-Content -Path rename.txt -Value @($name) -Encoding ASCII
          & $env:FEEDER_EXE --exe "$exe" --input "rename.txt" --delay 500 --kill-on "press any key" --kill-delay 200
          if ($LASTEXITCODE -ne 0) { throw "Rename run failed (exit $LASTEXITCODE)" }
          Remove-Item rename.txt -Force -ErrorAction SilentlyContinue

      - name: Detect solution after changes
        shell: pwsh
        run: |
          $sln = Get-ChildItem -Recurse -Filter *.sln | Select-Object -First 1
          if (-not $sln) { throw "No .sln found after modifications." }
          "SLN_PATH=$($sln.FullName)" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "Detected solution: $($sln.FullName)"

      - name: Restore
        shell: pwsh
        run: dotnet restore "$env:SLN_PATH"

      - name: Build (whole solution)
        shell: pwsh
        run: dotnet build --no-restore -c Release "$env:SLN_PATH"

      - name: Test
        shell: pwsh
        run: dotnet test --no-build -c Release "$env:SLN_PATH"

      - name: Collect compiled binaries
        shell: pwsh
        run: |
          $binRoot = Join-Path $pwd "artifacts\binaries"
          New-Item -ItemType Directory -Force -Path $binRoot | Out-Null

          Get-ChildItem -Recurse -Include bin,obj -Directory | ForEach-Object {
              $rel = Resolve-Path $_.FullName | ForEach-Object {
                  $_.Path.Substring((Resolve-Path $pwd).Path.Length).TrimStart('\')
              }
              $dest = Join-Path $binRoot ($rel -replace '[\\/:*?"<>|]', '_')
              New-Item -ItemType Directory -Force -Path $dest | Out-Null
              Copy-Item -Path (Join-Path $_.FullName '*') -Destination $dest -Recurse -Force
          }

      - name: Snapshot source after changes
        shell: pwsh
        run: |
          $src = $pwd.Path
          $dst = Join-Path $pwd "artifacts\source_after_changes"
          New-Item -ItemType Directory -Force -Path $dst | Out-Null
          $excludeDirs = @(".git","artifacts",".github","tools\StdInFeeder\out")
          $excludeFiles = @("*.suo","*.user","nuget.config","global.json")
          Get-ChildItem -Path $src -Recurse -File |
            Where-Object { ($excludeDirs -notcontains $_.Directory.Name) -and ($excludeFiles -notcontains $_.Name) } |
            ForEach-Object {
              $rel  = $_.FullName.Substring($src.Length).TrimStart('\')
              $dest = Join-Path $dst $rel
              New-Item -ItemType Directory -Force -Path (Split-Path $dest) | Out-Null
              Copy-Item -Path $_.FullName -Destination $dest -Force
            }
          Get-ChildItem -Path $dst -Recurse -Directory -Include bin,obj | ForEach-Object {
            try { Remove-Item -Recurse -Force -LiteralPath $_.FullName } catch { }
          }

      - name: Upload artifact • compiled_binaries
        uses: actions/upload-artifact@v4
        with:
          name: compiled_binaries
          path: artifacts/binaries

      - name: Upload artifact • source_after_changes
        uses: actions/upload-artifact@v4
        with:
          name: source_after_changes
          path: artifacts/source_after_changes

  #---------------------------------------------------------
  # Consumer job to prove artifacts are usable.
  #---------------------------------------------------------
  consumer:
    name: Consumer on fresh runner
    runs-on: windows-latest
    needs: build

    steps:
      - name: Download compiled_binaries
        uses: actions/download-artifact@v4
        with:
          name: compiled_binaries
          path: _consume/compiled_binaries

      - name: Download source_after_changes
        uses: actions/download-artifact@v4
        with:
          name: source_after_changes
          path: _consume/source_after_changes

      - name: List downloaded artifacts
        shell: pwsh
        run: |
          Write-Host "`n=== compiled_binaries ==="
          Get-ChildItem -Recurse -File _consume\compiled_binaries | Select-Object FullName, Length | Format-Table -AutoSize
          Write-Host "`n=== source_after_changes top-level ==="
          Get-ChildItem _consume\source_after_changes
