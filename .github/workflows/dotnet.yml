name: .NET (Windows • remove via feeder • safe rename • publish artifacts)

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      selections:
        description: "Comma-separated highest→lowest to remove (e.g., 6,5,4)"
        required: false
        default: "6,5,4,3,2,1"
      delay_ms:
        description: "Delay (ms) between lines sent to the apps"
        required: false
        default: "1000"
      app_name:
        description: "New application name for the rename tool (letters only, e.g., FreeCICD)"
        required: false
        default: "FreeCICD"

jobs:
  #---------------------------------------------------------
  # Build the small StdIn feeder as a single-file EXE
  # and upload it as an artifact for other jobs to use.
  #---------------------------------------------------------
  feeder:
    name: Build feeder
    runs-on: windows-latest

    steps:
      - name: Setup .NET SDK 8
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Create feeder project (with kill-on support)
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path tools\StdInFeeder | Out-Null

          $code = @'
          using System;
          using System.Diagnostics;
          using System.IO;
          using System.Text;
          using System.Threading.Tasks;

          class Program
          {
              static int Main(string[] args)
              {
                  string exe = null;
                  string inputPath = null;
                  int delay = 500;

                  // Optional: kill the child after a specific output line appears.
                  string killOn = null;    // e.g. "press any key"
                  int killDelay = 200;     // ms
                  bool killTriggered = false;

                  for (int i = 0; i < args.Length; i++)
                  {
                      switch (args[i])
                      {
                          case "--exe":        exe = args[++i]; break;
                          case "--input":      inputPath = args[++i]; break;
                          case "--delay":      delay = int.Parse(args[++i]); break;
                          case "--kill-on":    killOn = args[++i]; break;
                          case "--kill-delay": killDelay = int.Parse(args[++i]); break;
                      }
                  }

                  if (string.IsNullOrWhiteSpace(exe) || !File.Exists(exe))
                  {
                      Console.Error.WriteLine($"Target exe not found: {exe}");
                      return 2;
                  }
                  if (string.IsNullOrWhiteSpace(inputPath) || !File.Exists(inputPath))
                  {
                      Console.Error.WriteLine($"Input file not found: {inputPath}");
                      return 3;
                  }

                  var psi = new ProcessStartInfo
                  {
                      FileName = exe,
                      UseShellExecute = false,
                      RedirectStandardInput = true,
                      RedirectStandardOutput = true,
                      RedirectStandardError = true,
                      CreateNoWindow = true
                  };

                  using var p = new Process { StartInfo = psi };

                  p.OutputDataReceived += (_, e) =>
                  {
                      if (e.Data != null)
                      {
                          Console.WriteLine(e.Data);
                          if (!string.IsNullOrEmpty(killOn) &&
                              e.Data.IndexOf(killOn, StringComparison.OrdinalIgnoreCase) >= 0 &&
                              !killTriggered)
                          {
                              killTriggered = true;
                              _ = Task.Run(() =>
                              {
                                  try
                                  {
                                      System.Threading.Thread.Sleep(killDelay);
                                      if (!p.HasExited)
                                      {
                                          try { p.CloseMainWindow(); } catch { /* ignored */ }
                                          if (!p.HasExited) p.Kill(true);
                                      }
                                  }
                                  catch { /* ignore */ }
                              });
                          }
                      }
                  };
                  p.ErrorDataReceived += (_, e) => { if (e.Data != null) Console.Error.WriteLine(e.Data); };

                  if (!p.Start()) return 4;
                  p.BeginOutputReadLine();
                  p.BeginErrorReadLine();

                  foreach (var line in File.ReadAllLines(inputPath, Encoding.ASCII))
                  {
                      p.StandardInput.WriteLine(line);
                      p.StandardInput.Flush();
                      System.Threading.Thread.Sleep(delay);
                  }
                  p.StandardInput.Close();

                  p.WaitForExit();

                  // If we purposely killed after seeing the sentinel output, treat as success.
                  return killTriggered ? 0 : p.ExitCode;
              }
          }
          '@
          Set-Content -Path tools\StdInFeeder\Program.cs -Value $code -Encoding UTF8

          $proj = @'
          <Project Sdk="Microsoft.NET.Sdk">
            <PropertyGroup>
              <OutputType>Exe</OutputType>
              <TargetFramework>net8.0</TargetFramework>
              <ImplicitUsings>enable</ImplicitUsings>
              <Nullable>enable</Nullable>
              <PublishSingleFile>true</PublishSingleFile>
              <RuntimeIdentifier>win-x64</RuntimeIdentifier>
              <SelfContained>false</SelfContained>
            </PropertyGroup>
          </Project>
          '@
          Set-Content -Path tools\StdInFeeder\StdInFeeder.csproj -Value $proj -Encoding UTF8

      - name: Publish feeder
        shell: pwsh
        run: |
          dotnet publish tools\StdInFeeder -c Release -o tools\StdInFeeder\out
          Get-ChildItem tools\StdInFeeder\out

      - name: Upload feeder artifact
        uses: actions/upload-artifact@v4
        with:
          name: stdin_feeder
          path: tools/StdInFeeder/out

  #---------------------------------------------------------
  # Main job: checkout repo, download feeder artifact,
  # run removal tool and rename tool via feeder,
  # build/test, collect & upload artifacts.
  #---------------------------------------------------------
  build:
    name: Build & publish
    runs-on: windows-latest
    needs: feeder

    env:
      REMOVE_EXE: '.\Remove Modules from FreeCRM.exe'
      RENAME_EXE: '.\Rename FreeCRM.exe'
      FEEDER_EXE: '.\tools\StdInFeeder\out\StdInFeeder.exe'
      # These may be empty for push/PR; the scripts below default them.
      SELECTIONS: ${{ github.event.inputs.selections }}
      DELAY_MS:  ${{ github.event.inputs.delay_ms }}
      APP_NAME:  ${{ github.event.inputs.app_name }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET 9 & 8 SDKs
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            9.0.x
            8.0.x

      - name: Download feeder artifact
        uses: actions/download-artifact@v4
        with:
          name: stdin_feeder
          path: tools/StdInFeeder/out

      - name: Verify feeder exists
        shell: pwsh
        run: |
          if (-not (Test-Path $env:FEEDER_EXE)) { throw "Feeder EXE not found at $env:FEEDER_EXE" }
          Get-Item $env:FEEDER_EXE | Format-List *

      # --- Generate input and run the remove utility N times highest→lowest ---
      - name: Remove modules using feeder
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $exe = $env:REMOVE_EXE
          if (-not (Test-Path $exe)) { throw "Remove utility not found at: $exe" }

          $selections = if ([string]::IsNullOrWhiteSpace($env:SELECTIONS)) { "6,5,4,3,2,1" } else { $env:SELECTIONS }
          $delayMs    = if ([string]::IsNullOrWhiteSpace($env:DELAY_MS)) { 1000 } else { [int]$env:DELAY_MS }

          $targets =
            $selections -split ',' |
            ForEach-Object { $_.Trim() } |
            Where-Object { $_ -match '^\d+$' } |
            ForEach-Object { [int]$_ } |
            Sort-Object -Descending

          if (-not $targets) { throw "No valid numeric selections in: '$selections'" }

          foreach ($n in $targets) {
            Write-Host "`n=== $exe with selection $n, then 'x' ==="
            Set-Content -Path input.txt -Value @("$n","x") -Encoding ASCII
            & $env:FEEDER_EXE --exe "$exe" --input "input.txt" --delay $delayMs
            if ($LASTEXITCODE -ne 0) { throw "Remove run failed for selection $n (exit $LASTEXITCODE)" }
            Remove-Item input.txt -Force -ErrorAction SilentlyContinue
          }

      # --- Rename safely (the tool asks for a keypress; we kill after its "press any key" line) ---
      - name: Rename project using feeder (safe for CI)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $exe  = $env:RENAME_EXE
          if (-not (Test-Path $exe)) { throw "Rename utility not found at: $exe" }

          $name = if ([string]::IsNullOrWhiteSpace($env:APP_NAME)) { "FreeCICD" } else { $env:APP_NAME }
          if ($name -notmatch '^[A-Za-z]+$') { throw "APP_NAME '$name' is invalid. Use letters only (e.g., FreeCICD)." }

          Set-Content -Path rename.txt -Value @($name) -Encoding ASCII
          # Kill-on matches "Rename completed, press any key to exit"
          & $env:FEEDER_EXE --exe "$exe" --input "rename.txt" --delay 500 --kill-on "press any key" --kill-delay 200
          if ($LASTEXITCODE -ne 0) { throw "Rename run failed (exit $LASTEXITCODE)" }
          Remove-Item rename.txt -Force -ErrorAction SilentlyContinue

      # --- Build/Test the renamed/trimmed solution ---
      - name: Detect solution after changes
        shell: pwsh
        run: |
          $sln = Get-ChildItem -Recurse -Filter *.sln | Select-Object -First 1
          if (-not $sln) { throw "No .sln found after modifications." }
          "SLN_PATH=$($sln.FullName)" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "Detected solution: $($sln.FullName)"

      - name: Restore
        shell: pwsh
        run: dotnet restore "$env:SLN_PATH"

      - name: Build
        shell: pwsh
        run: dotnet build --no-restore -c Release "$env:SLN_PATH"

      - name: Test
        shell: pwsh
        run: dotnet test --no-build -c Release --verbosity normal "$env:SLN_PATH"

      # --- Publish and collect artifacts ---
      - name: dotnet publish (all publishable projects in solution)
        shell: pwsh
        run: |
          dotnet publish "$env:SLN_PATH" -c Release
          # Collect all publish folders to a common directory
          $pubRoot = Join-Path $pwd "artifacts\publish"
          New-Item -ItemType Directory -Force -Path $pubRoot | Out-Null
          $pubDirs = Get-ChildItem -Recurse -Directory -Filter publish
          foreach ($d in $pubDirs) {
            $rel = $d.FullName.Substring($pwd.Path.Length).TrimStart('\')
            $dest = Join-Path $pubRoot ($rel -replace '[\\/:*?"<>|]', '_')
            New-Item -ItemType Directory -Force -Path $dest | Out-Null
            Write-Host "Copying publish output: $rel -> $dest"
            robocopy $d.FullName $dest /E | Out-Null
            if ($LASTEXITCODE -gt 7) { throw "robocopy failed copying publish dir ($rel) with code $LASTEXITCODE" }
          }

      - name: Collect compiled binaries (bin\Release excluding publish)
        shell: pwsh
        run: |
          $binRoot = Join-Path $pwd "artifacts\binaries"
          New-Item -ItemType Directory -Force -Path $binRoot | Out-Null
          $binDirs = Get-ChildItem -Recurse -Directory -Filter Release | Where-Object { $_.FullName -match '\\bin\\' }
          foreach ($b in $binDirs) {
            if ($b.FullName -match '\\publish(\\|$)') { continue }
            $rel = $b.FullName.Substring($pwd.Path.Length).TrimStart('\')
            $dest = Join-Path $binRoot ($rel -replace '[\\/:*?"<>|]', '_')
            New-Item -ItemType Directory -Force -Path $dest | Out-Null
            Write-Host "Copying binaries: $rel -> $dest"
            robocopy $b.FullName $dest /E | Out-Null
            if ($LASTEXITCODE -gt 7) { throw "robocopy failed copying binaries ($rel) with code $LASTEXITCODE" }
          }

      - name: Snapshot source after changes (exclude .git/bin/obj/artifacts)
        shell: pwsh
        run: |
          $src = $pwd.Path
          $dst = Join-Path $pwd "artifacts\source_after_changes"
          New-Item -ItemType Directory -Force -Path $dst | Out-Null
          # Mirror while excluding common heavy folders
          robocopy $src $dst /MIR /XD ".git" "artifacts" ".github" "tools\StdInFeeder\out" /XF "*.suo" "*.user" "appsettings.*.json" "appsettings.json" "nuget.config" "global.json" | Out-Null
          if ($LASTEXITCODE -gt 7) { throw "robocopy failed mirroring source with code $LASTEXITCODE" }
          # Remove bin/obj everywhere inside snapshot
          Get-ChildItem -Path $dst -Recurse -Directory -Include bin,obj | ForEach-Object {
            try { Remove-Item -Recurse -Force -LiteralPath $_.FullName } catch { }
          }

      - name: Upload artifact • published_web
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: published_web
          path: artifacts/publish

      - name: Upload artifact • compiled_binaries
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: compiled_binaries
          path: artifacts/binaries

      - name: Upload artifact • source_after_changes
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: source_after_changes
          path: artifacts/source_after_changes

  #---------------------------------------------------------
  # Simple consumer job on a fresh runner: download artifacts
  # produced above to prove they can be consumed.
  #---------------------------------------------------------
  consumer:
    name: Consumer on fresh runner
    runs-on: windows-latest
    needs: build

    steps:
      - name: Download published_web
        uses: actions/download-artifact@v4
        with:
          name: published_web
          path: _consume/published_web

      - name: Download compiled_binaries
        uses: actions/download-artifact@v4
        with:
          name: compiled_binaries
          path: _consume/compiled_binaries

      - name: Download source_after_changes
        uses: actions/download-artifact@v4
        with:
          name: source_after_changes
          path: _consume/source_after_changes

      - name: List downloaded artifacts
        shell: pwsh
        run: |
          Write-Host "`n=== published_web ==="
          Get-ChildItem -Recurse -File _consume\published_web | Select-Object FullName, Length | Format-Table -AutoSize
          Write-Host "`n=== compiled_binaries ==="
          Get-ChildItem -Recurse -File _consume\compiled_binaries | Select-Object FullName, Length | Format-Table -AutoSize
          Write-Host "`n=== source_after_changes top-level ==="
          Get-ChildItem _consume\source_after_changes
