name: .NET (Windows + Pre-Build Utilities)

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      selections:
        description: "Comma-separated highest→lowest selections to remove (e.g., 6,5,4)"
        required: false
        default: "6,5,4,3,2,1"

jobs:
  build:
    runs-on: windows-latest

    env:
      # EXEs live in repo root (with spaces in names)
      REMOVE_EXE: ".\Remove Modules from FreeCRM.exe"
      RENAME_EXE: ".\Rename FreeCRM.exe"
      # Only populated for manual dispatch; we'll default in-script for push/PR
      SELECTIONS: ${{ github.event.inputs.selections }}

    steps:
      - uses: actions/checkout@v4

      # --- Install .NET FIRST (SDK includes the runtime) ---
      - name: Setup .NET 9 & 8 SDKs
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            9.0.x
            8.0.x
      - name: Verify .NET
        shell: pwsh
        run: |
          dotnet --info
          dotnet --list-sdks

      # --- Utilities BEFORE building ---

      - name: Run rename utility (optional)
        shell: pwsh
        run: |
          $exe = $env:RENAME_EXE
          if (Test-Path $exe) {
            Write-Host "Running rename utility: $exe"
            & "$exe"
            if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }
          } else {
            Write-Host "Rename EXE not found at: $exe — skipping."
          }

      - name: Remove modules (highest → lowest) with STDIN file
        shell: pwsh
        run: |
          $exe = $env:REMOVE_EXE
          if (-not (Test-Path $exe)) { throw "Remove utility not found at: $exe" }

          # Use dispatch input if provided; otherwise default for push/PR
          $selections = $env:SELECTIONS
          if ([string]::IsNullOrWhiteSpace($selections)) { $selections = "6,5,4,3,2,1" }

          $targets =
            $selections -split ',' |
            ForEach-Object { $_.Trim() } |
            Where-Object { $_ -match '^\d+$' } |
            ForEach-Object { [int]$_ } |
            Sort-Object -Descending  # enforce highest→lowest even if user passes unordered

          if (-not $targets) { throw "No valid numeric selections in: '$selections'" }

          Write-Host "Selections to remove (highest→lowest): $($targets -join ', ')"

          foreach ($n in $targets) {
            Write-Host "`n=== $exe with selection $n, then 'x' ==="

            # Build file content with CRLF line endings: "<n>\r\nx\r\n"
            $inputText = "$n`r`nx`r`n"
            Set-Content -Path input.txt -Value $inputText -NoNewline -Encoding ascii

            # Feed the file to STDIN for the console app
            & "$exe" < input.txt
            if ($LASTEXITCODE -ne 0) { throw "Run failed for selection $n (exit $LASTEXITCODE)" }

            Remove-Item input.txt -Force -ErrorAction SilentlyContinue
            Start-Sleep -Seconds 1
          }

          Write-Host "`nAll removals completed."

      # --- Then the .NET build/test ---

      - name: Restore
        shell: pwsh
        run: dotnet restore

      - name: Build
        shell: pwsh
        run: dotnet build --no-restore

      - name: Test
        shell: pwsh
        run: dotnet test --no-build --verbosity normal
