name: .NET (Windows + Remove via feeder)

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      selections:
        description: "Comma-separated highest→lowest to remove (e.g., 6,5,4)"
        required: false
        default: "6,5,4,3,2,1"
      delay_ms:
        description: "Delay (ms) between lines sent to the app"
        required: false
        default: "1000"

jobs:
  build:
    runs-on: windows-latest

    env:
      REMOVE_EXE: '.\Remove Modules from FreeCRM.exe'
      SELECTIONS: ${{ github.event.inputs.selections }}
      DELAY_MS:  ${{ github.event.inputs.delay_ms }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET 9 & 8 SDKs
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            9.0.x
            8.0.x

      # --- Build a tiny feeder that reads a text file and writes each line (with delay) to STDIN ---
      - name: Create feeder project
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path tools\StdInFeeder | Out-Null

          $code = @(
            'using System;'
            'using System.Diagnostics;'
            'using System.IO;'
            'using System.Text;'
            ''
            'class Program'
            '{'
            '    static int Main(string[] args)'
            '    {'
            '        string exe = null;'
            '        string inputPath = null;'
            '        int delay = 500;'
            '        for (int i = 0; i < args.Length; i++)'
            '        {'
            '            switch (args[i])'
            '            {'
            '                case "--exe":   exe = args[++i]; break;'
            '                case "--input": inputPath = args[++i]; break;'
            '                case "--delay": delay = int.Parse(args[++i]); break;'
            '            }'
            '        }'
            '        if (string.IsNullOrWhiteSpace(exe) || !File.Exists(exe))'
            '        {'
            '            Console.Error.WriteLine($"Target exe not found: {exe}");'
            '            return 2;'
            '        }'
            '        if (string.IsNullOrWhiteSpace(inputPath) || !File.Exists(inputPath))'
            '        {'
            '            Console.Error.WriteLine($"Input file not found: {inputPath}");'
            '            return 3;'
            '        }'
            '        var psi = new ProcessStartInfo'
            '        {'
            '            FileName = exe,'
            '            UseShellExecute = false,'
            '            RedirectStandardInput = true,'
            '            RedirectStandardOutput = true,'
            '            RedirectStandardError = true,'
            '            CreateNoWindow = true'
            '        };'
            '        using var p = new Process { StartInfo = psi };'
            '        p.OutputDataReceived += (_, e) => { if (e.Data != null) Console.WriteLine(e.Data); };'
            '        p.ErrorDataReceived  += (_, e) => { if (e.Data != null) Console.Error.WriteLine(e.Data); };'
            '        if (!p.Start()) return 4;'
            '        p.BeginOutputReadLine();'
            '        p.BeginErrorReadLine();'
            '        foreach (var line in File.ReadAllLines(inputPath, Encoding.ASCII))'
            '        {'
            '            p.StandardInput.WriteLine(line);'
            '            p.StandardInput.Flush();'
            '            System.Threading.Thread.Sleep(delay);'
            '        }'
            '        p.StandardInput.Close();'
            '        p.WaitForExit();'
            '        return p.ExitCode;'
            '    }'
            '}'
          )
          Set-Content -Path tools\StdInFeeder\Program.cs -Value $code -Encoding UTF8

          $proj = @(
            '<Project Sdk="Microsoft.NET.Sdk">',
            '  <PropertyGroup>',
            '    <OutputType>Exe</OutputType>',
            '    <TargetFramework>net8.0</TargetFramework>',
            '    <ImplicitUsings>enable</ImplicitUsings>',
            '    <Nullable>enable</Nullable>',
            '    <PublishSingleFile>true</PublishSingleFile>',
            '    <RuntimeIdentifier>win-x64</RuntimeIdentifier>',
            '    <SelfContained>false</SelfContained>',
            '  </PropertyGroup>',
            '</Project>'
          )
          Set-Content -Path tools\StdInFeeder\StdInFeeder.csproj -Value $proj -Encoding UTF8

          dotnet publish tools\StdInFeeder -c Release -o tools\StdInFeeder\out

      # --- Generate input and run the remove utility N times highest→lowest ---
      - name: Remove modules using feeder
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $exe = $env:REMOVE_EXE
          if (-not (Test-Path $exe)) { throw "Remove utility not found at: $exe" }

          $selections = if ([string]::IsNullOrWhiteSpace($env:SELECTIONS)) { "6,5,4,3,2,1" } else { $env:SELECTIONS }
          $delayMs    = if ([string]::IsNullOrWhiteSpace($env:DELAY_MS)) { 1000 } else { [int]$env:DELAY_MS }

          $targets =
            $selections -split ',' |
            ForEach-Object { $_.Trim() } |
            Where-Object { $_ -match '^\d+$' } |
            ForEach-Object { [int]$_ } |
            Sort-Object -Descending

          if (-not $targets) { throw "No valid numeric selections in: '$selections'" }

          $feeder = ".\tools\StdInFeeder\out\StdInFeeder.exe"

          foreach ($n in $targets) {
            Write-Host "`n=== $exe with selection $n, then 'x' ==="
            # Build a simple input file: line1=selection, line2=x
            Set-Content -Path input.txt -Value @("$n","x") -Encoding ASCII

            & $feeder --exe "$exe" --input "input.txt" --delay $delayMs
            if ($LASTEXITCODE -ne 0) { throw "Remove run failed for selection $n (exit $LASTEXITCODE)" }

            Remove-Item input.txt -Force -ErrorAction SilentlyContinue
          }

      # --- Build/Test the renamed/trimmed solution ---
      - name: Detect solution after changes
        shell: pwsh
        run: |
          $sln = Get-ChildItem -Recurse -Filter *.sln | Select-Object -First 1
          if (-not $sln) { throw "No .sln found after modifications." }
          "SLN_PATH=$($sln.FullName)" | Out-File -FilePath $env:GITHUB_ENV -Append

      - name: Restore
        shell: pwsh
        run: dotnet restore "$env:SLN_PATH"

      - name: Build
        shell: pwsh
        run: dotnet build --no-restore "$env:SLN_PATH"

      - name: Test
        shell: pwsh
        run: dotnet test --no-build --verbosity normal "$env:SLN_PATH"
