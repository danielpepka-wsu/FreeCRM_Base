name: .NET (Windows • remove via feeder • safe rename • source snapshot)

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      selections:
        description: "Comma-separated highest→lowest to remove (e.g., 6,5,4)"
        required: false
        default: "6,5,4,3,2,1"
      delay_ms:
        description: "Delay (ms) between lines sent to the apps"
        required: false
        default: "1000"
      app_name:
        description: "New application name for the rename tool (letters only, e.g., FreeCICD)"
        required: false
        default: "FreeCICD"

permissions:
  contents: write

#---------------------------------------------------------
# Global environment variables
#---------------------------------------------------------
env:
  SELECTIONS: ${{ github.event.inputs.selections || '6,5,4,3,2,1' }}
  DELAY_MS:  ${{ github.event.inputs.delay_ms    || '1000' }}
  APP_NAME:  ${{ github.event.inputs.app_name    || 'FreeCICD' }}

  REMOVE_EXE: '.\Remove Modules from FreeCRM.exe'
  RENAME_EXE: '.\Rename FreeCRM.exe'
  FEEDER_EXE: '.\tools\StdInFeeder\out\StdInFeeder.exe'

  BASE_BRANCH: FreeCRM_base

jobs:
  #---------------------------------------------------------
  # Build the small StdIn feeder and upload it.
  #---------------------------------------------------------
  feeder:
    name: Build feeder
    runs-on: windows-latest

    steps:
      - name: Setup .NET SDK 8
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Create feeder project (with kill-on support)
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path tools\StdInFeeder | Out-Null

          $code = @'
          using System;
          using System.Diagnostics;
          using System.IO;
          using System.Text;
          using System.Threading.Tasks;

          class Program
          {
              static int Main(string[] args)
              {
                  string exe = null;
                  string inputPath = null;
                  int delay = 500;

                  string killOn = null;
                  int killDelay = 200;
                  bool killTriggered = false;

                  for (int i = 0; i < args.Length; i++)
                  {
                      switch (args[i])
                      {
                          case "--exe":        exe = args[++i]; break;
                          case "--input":      inputPath = args[++i]; break;
                          case "--delay":      delay = int.Parse(args[++i]); break;
                          case "--kill-on":    killOn = args[++i]; break;
                          case "--kill-delay": killDelay = int.Parse(args[++i]); break;
                      }
                  }

                  if (string.IsNullOrWhiteSpace(exe) || !File.Exists(exe))
                  {
                      Console.Error.WriteLine($"Target exe not found: {exe}");
                      return 2;
                  }
                  if (string.IsNullOrWhiteSpace(inputPath) || !File.Exists(inputPath))
                  {
                      Console.Error.WriteLine($"Input file not found: {inputPath}");
                      return 3;
                  }

                  var psi = new ProcessStartInfo
                  {
                      FileName = exe,
                      UseShellExecute = false,
                      RedirectStandardInput = true,
                      RedirectStandardOutput = true,
                      RedirectStandardError = true,
                      CreateNoWindow = true
                  };

                  using var p = new Process { StartInfo = psi };

                  p.OutputDataReceived += (_, e) =>
                  {
                      if (e.Data != null)
                      {
                          Console.WriteLine(e.Data);
                          if (!string.IsNullOrEmpty(killOn) &&
                              e.Data.IndexOf(killOn, StringComparison.OrdinalIgnoreCase) >= 0 &&
                              !killTriggered)
                          {
                              killTriggered = true;
                              _ = Task.Run(() =>
                              {
                                  try
                                  {
                                      System.Threading.Thread.Sleep(killDelay);
                                      if (!p.HasExited)
                                      {
                                          try { p.CloseMainWindow(); } catch { }
                                          if (!p.HasExited) p.Kill(true);
                                      }
                                  }
                                  catch { }
                              });
                          }
                      }
                  };
                  p.ErrorDataReceived += (_, e) => { if (e.Data != null) Console.Error.WriteLine(e.Data); };

                  if (!p.Start()) return 4;
                  p.BeginOutputReadLine();
                  p.BeginErrorReadLine();

                  foreach (var line in File.ReadAllLines(inputPath, Encoding.ASCII))
                  {
                      p.StandardInput.WriteLine(line);
                      p.StandardInput.Flush();
                      System.Threading.Thread.Sleep(delay);
                  }
                  p.StandardInput.Close();

                  p.WaitForExit();

                  return killTriggered ? 0 : p.ExitCode;
              }
          }
          '@
          Set-Content -Path tools\StdInFeeder\Program.cs -Value $code -Encoding UTF8

          $proj = @'
          <Project Sdk="Microsoft.NET.Sdk">
            <PropertyGroup>
              <OutputType>Exe</OutputType>
              <TargetFramework>net8.0</TargetFramework>
              <PublishSingleFile>true</PublishSingleFile>
              <RuntimeIdentifier>win-x64</RuntimeIdentifier>
              <SelfContained>false</SelfContained>
            </PropertyGroup>
          </Project>
          '@
          Set-Content -Path tools\StdInFeeder\StdInFeeder.csproj -Value $proj -Encoding UTF8

      - name: Publish feeder
        shell: pwsh
        run: |
          dotnet publish tools\StdInFeeder -c Release -o tools\StdInFeeder\out
          Get-ChildItem tools\StdInFeeder\out

      - name: Upload feeder artifact
        uses: actions/upload-artifact@v4
        with:
          name: stdin_feeder
          path: tools/StdInFeeder/out

  #---------------------------------------------------------
  # Main job: modify repo, package source, then build/test.
  #---------------------------------------------------------
  build:
    name: Modify & snapshot source, then build
    runs-on: windows-latest
    needs: feeder

    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET 9 & 8 SDKs
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            9.0.x
            8.0.x

      - name: Download feeder artifact
        uses: actions/download-artifact@v4
        with:
          name: stdin_feeder
          path: tools/StdInFeeder/out

      - name: Run remove modules helper
        shell: pwsh
        run: |
          $exe = $env:REMOVE_EXE
          $targets =
            $env:SELECTIONS -split ',' |
            ForEach-Object { $_.Trim() } |
            Where-Object { $_ -match '^\d+$' } |
            ForEach-Object { [int]$_ } |
            Sort-Object -Descending

          foreach ($n in $targets) {
            Write-Host "`n=== $exe with selection $n, then 'x' ==="
            Set-Content -Path input.txt -Value @("$n","x") -Encoding ASCII
            & $env:FEEDER_EXE --exe "$exe" --input "input.txt" --delay $env:DELAY_MS
            if ($LASTEXITCODE -ne 0) { throw "Remove run failed for selection $n (exit $LASTEXITCODE)" }
            Remove-Item input.txt -Force -ErrorAction SilentlyContinue
          }

      - name: Run rename helper
        shell: pwsh
        run: |
          $exe  = $env:RENAME_EXE
          if ($env:APP_NAME -notmatch '^[A-Za-z]+$') { throw "APP_NAME '$env:APP_NAME' is invalid." }

          Set-Content -Path rename.txt -Value @($env:APP_NAME) -Encoding ASCII
          & $env:FEEDER_EXE --exe "$exe" --input "rename.txt" --delay 500 --kill-on "press any key" --kill-delay 200
          if ($LASTEXITCODE -ne 0) { throw "Rename run failed (exit $LASTEXITCODE)" }
          Remove-Item rename.txt -Force -ErrorAction SilentlyContinue

      - name: Clean up helper tools
        shell: pwsh
        run: |
          Remove-Item -Recurse -Force "tools\StdInFeeder" -ErrorAction SilentlyContinue
          Remove-Item "$env:REMOVE_EXE" -ErrorAction SilentlyContinue
          Remove-Item "$env:RENAME_EXE" -ErrorAction SilentlyContinue

      - name: Snapshot source after changes
        shell: pwsh
        run: |
          $src = $pwd.Path
          $zip = Join-Path $pwd "artifacts\source_after_changes.zip"
          New-Item -ItemType Directory -Force -Path (Split-Path $zip) | Out-Null

          # Zip everything except .git, .github, artifacts
          $items = Get-ChildItem $src -Recurse -Force | Where-Object {
            $_.FullName -notmatch '\\\.git($|\\)' -and
            $_.FullName -notmatch '\\\.github($|\\)' -and
            $_.FullName -notmatch '\\artifacts($|\\)'
          }

          Compress-Archive -Path $items.FullName -DestinationPath $zip -Force

      - name: Upload artifact • source_after_changes
        uses: actions/upload-artifact@v4
        with:
          name: source_after_changes
          path: artifacts/source_after_changes.zip

      - name: Detect solution after changes
        shell: pwsh
        run: |
          $sln = Get-ChildItem -Recurse -Filter *.sln | Select-Object -First 1
          if (-not $sln) { throw "No .sln found after modifications." }
          "SLN_PATH=$($sln.FullName)" | Out-File -FilePath $env:GITHUB_ENV -Append

      - name: Restore
        shell: pwsh
        run: dotnet restore "$env:SLN_PATH"

      - name: Build (whole solution)
        shell: pwsh
        run: dotnet build --no-restore -c Release "$env:SLN_PATH"

      - name: Test
        shell: pwsh
        run: dotnet test --no-build -c Release "$env:SLN_PATH"

  consumer:
    name: Consumer on fresh runner
    runs-on: windows-latest
    needs: build

    steps:
      - name: Download source_after_changes
        uses: actions/download-artifact@v4
        with:
          name: source_after_changes
          path: _consume/source_after_changes

      - name: List downloaded source
        shell: pwsh
        run: |
          Write-Host "`n=== source_after_changes top-level ==="
          Get-ChildItem _consume\source_after_changes

  #---------------------------------------------------------
  # New job: update FreeCRM_base branch with snapshot.
  #---------------------------------------------------------
  update-branch:
    name: Replace FreeCRM_base branch with new contents
    runs-on: ubuntu-latest
    needs: build

    steps:
      - name: Download source_after_changes
        uses: actions/download-artifact@v4
        with:
          name: source_after_changes
          path: _consume

      - name: Checkout branch
        uses: actions/checkout@v4
        with:
          ref: ${{ env.BASE_BRANCH }}
          fetch-depth: 0

      - name: Reset branch contents with new archive
        run: |
          set -e
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git checkout -B "${BASE_BRANCH}"

          # Clear all contents
          git rm -rf . || true

          # Extract new files
          unzip -o _consume/source_after_changes.zip -d .

          # Stage and commit
          git add -A
          git commit -m "Replace with regenerated FreeCRM base" || echo "No changes to commit"

          # Force push
          git push origin HEAD:${BASE_BRANCH} --force
