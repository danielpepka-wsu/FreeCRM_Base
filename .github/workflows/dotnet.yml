name: .NET (Windows • multi-project remove via feeder • safe rename • source snapshot)

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      selections:
        description: "Comma-separated highest→lowest to remove (overrides matrix)"
        required: false
        default: ""
      delay_ms:
        description: "Delay (ms) between lines sent to the apps"
        required: false
        default: "1000"
      app_name:
        description: "New application name for the rename tool (overrides matrix)"
        required: false
        default: ""

permissions:
  contents: write

#---------------------------------------------------------
# Job 1: Build feeder exe (runs once, shared by all projects)
#---------------------------------------------------------
jobs:
  feeder:
    name: Job 1 • Build feeder
    runs-on: windows-latest
    steps:
      ## Step 1.1: Setup .NET SDK 8 (needed to build our helper)
      - name: Setup .NET SDK 8
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      ## Step 1.2: Create feeder project (small console app to feed text input into EXEs)
      - name: Create feeder project
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path tools\StdInFeeder | Out-Null
          # Program.cs: reads --exe and --input args, feeds lines into target EXE with delays,
          # optionally kills on matching output text.
          $code = @'
          using System;
          using System.Diagnostics;
          using System.IO;
          using System.Text;
          using System.Threading.Tasks;
          class Program {
              static int Main(string[] args) {
                  string exe = null;
                  string inputPath = null;
                  int delay = 500;
                  string killOn = null;
                  int killDelay = 200;
                  bool killTriggered = false;
                  for (int i = 0; i < args.Length; i++) {
                      switch (args[i]) {
                          case "--exe":        exe = args[++i]; break;
                          case "--input":      inputPath = args[++i]; break;
                          case "--delay":      delay = int.Parse(args[++i]); break;
                          case "--kill-on":    killOn = args[++i]; break;
                          case "--kill-delay": killDelay = int.Parse(args[++i]); break;
                      }
                  }
                  if (string.IsNullOrWhiteSpace(exe) || !File.Exists(exe)) {
                      Console.Error.WriteLine($"Target exe not found: {exe}"); return 2;
                  }
                  if (string.IsNullOrWhiteSpace(inputPath) || !File.Exists(inputPath)) {
                      Console.Error.WriteLine($"Input file not found: {inputPath}"); return 3;
                  }
                  var psi = new ProcessStartInfo {
                      FileName = exe,
                      UseShellExecute = false,
                      RedirectStandardInput = true,
                      RedirectStandardOutput = true,
                      RedirectStandardError = true,
                      CreateNoWindow = true
                  };
                  using var p = new Process { StartInfo = psi };
                  p.OutputDataReceived += (_, e) => {
                      if (e.Data != null) {
                          Console.WriteLine(e.Data);
                          if (!string.IsNullOrEmpty(killOn) &&
                              e.Data.IndexOf(killOn, StringComparison.OrdinalIgnoreCase) >= 0 &&
                              !killTriggered) {
                              killTriggered = true;
                              _ = Task.Run(() => {
                                  try {
                                      System.Threading.Thread.Sleep(killDelay);
                                      if (!p.HasExited) {
                                          try { p.CloseMainWindow(); } catch { }
                                          if (!p.HasExited) p.Kill(true);
                                      }
                                  } catch { }
                              });
                          }
                      }
                  };
                  p.ErrorDataReceived += (_, e) => { if (e.Data != null) Console.Error.WriteLine(e.Data); };
                  if (!p.Start()) return 4;
                  p.BeginOutputReadLine();
                  p.BeginErrorReadLine();
                  foreach (var line in File.ReadAllLines(inputPath, Encoding.ASCII)) {
                      p.StandardInput.WriteLine(line);
                      p.StandardInput.Flush();
                      System.Threading.Thread.Sleep(delay);
                  }
                  p.StandardInput.Close();
                  p.WaitForExit();
                  return killTriggered ? 0 : p.ExitCode;
              }
          }
          '@
          Set-Content -Path tools\StdInFeeder\Program.cs -Value $code -Encoding UTF8

          # Simple .csproj configured for single-file publish
          $proj = @'
          <Project Sdk="Microsoft.NET.Sdk">
            <PropertyGroup>
              <OutputType>Exe</OutputType>
              <TargetFramework>net8.0</TargetFramework>
              <PublishSingleFile>true</PublishSingleFile>
              <RuntimeIdentifier>win-x64</RuntimeIdentifier>
              <SelfContained>false</SelfContained>
            </PropertyGroup>
          </Project>
          '@
          Set-Content -Path tools\StdInFeeder\StdInFeeder.csproj -Value $proj -Encoding UTF8

      ## Step 1.3: Build the feeder into a single EXE
      - name: Publish feeder
        shell: pwsh
        run: dotnet publish tools\StdInFeeder -c Release -o tools\StdInFeeder\out

      ## Step 1.4: Upload feeder artifact so downstream jobs can use it
      - name: Upload feeder artifact
        uses: actions/upload-artifact@v4
        with:
          name: stdin_feeder
          path: tools/StdInFeeder/out

#---------------------------------------------------------
# Job 2 (matrix): Process each project (FreeCICD, FreeLLM, …)
#---------------------------------------------------------
  project:
    name: Job 2 • Process ${{ matrix.project.name }}
    runs-on: windows-latest
    needs: feeder

    strategy:
      fail-fast: false
      matrix:
        project:
          - name: FreeCICD
            branch: FreeCICD_base
            selections: "6,5,4,3,2,1"
          - name: FreeLLM
            branch: FreeLLM_base
            selections: "7,6,5,4,3,2,1"

    env:
      # Allow override from workflow_dispatch inputs, otherwise fall back to matrix values
      SELECTIONS: ${{ github.event.inputs.selections || matrix.project.selections }}
      APP_NAME:  ${{ github.event.inputs.app_name || matrix.project.name }}
      BASE_BRANCH: ${{ matrix.project.branch }}
      DELAY_MS:  ${{ github.event.inputs.delay_ms || '1000' }}
      REMOVE_EXE: '.\Remove Modules from FreeCRM.exe'
      RENAME_EXE: '.\Rename FreeCRM.exe'
      FEEDER_EXE: '.\tools\StdInFeeder\out\StdInFeeder.exe'

    steps:
      ## Step 2.1: Checkout repo (pulls FreeCRM_Base code including main branch)
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      ## Step 2.2: Setup .NET SDKs (9 for app, 8 for helper compatibility)
      - name: Setup .NET 9 & 8
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            9.0.x
            8.0.x

      ## Step 2.3: Bring in feeder artifact from Job 1
      - name: Download feeder artifact
        uses: actions/download-artifact@v4
        with:
          name: stdin_feeder
          path: tools/StdInFeeder/out

      ## Step 2.4: Remove modules based on SELECTIONS
      - name: Run remove modules helper
        shell: pwsh
        run: |
          $exe = $env:REMOVE_EXE
          $targets = $env:SELECTIONS -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ -match '^\d+$' } | ForEach-Object { [int]$_ } | Sort-Object -Descending
          foreach ($n in $targets) {
            Set-Content -Path input.txt -Value @("$n","x") -Encoding ASCII
            & $env:FEEDER_EXE --exe "$exe" --input "input.txt" --delay $env:DELAY_MS
            if ($LASTEXITCODE -ne 0) { throw "Remove run failed for selection $n (exit $LASTEXITCODE)" }
            Remove-Item input.txt -Force
          }

      ## Step 2.5: Run rename helper (renames app to APP_NAME)
      - name: Run rename helper
        shell: pwsh
        run: |
          $exe = $env:RENAME_EXE
          if ($env:APP_NAME -notmatch '^[A-Za-z]+$') { throw "APP_NAME '$env:APP_NAME' is invalid." }
          Set-Content -Path rename.txt -Value @($env:APP_NAME) -Encoding ASCII
          & $env:FEEDER_EXE --exe "$exe" --input "rename.txt" --delay 500 --kill-on "press any key" --kill-delay 200
          if ($LASTEXITCODE -ne 0) { throw "Rename run failed (exit $LASTEXITCODE)" }
          Remove-Item rename.txt -Force

      ## Step 2.6: Clean helper EXEs so they don’t pollute the snapshot
      - name: Clean up helper tools
        shell: pwsh
        run: |
          Remove-Item -Recurse -Force "tools\StdInFeeder" -ErrorAction SilentlyContinue
          Remove-Item "$env:REMOVE_EXE" -ErrorAction SilentlyContinue
          Remove-Item "$env:RENAME_EXE" -ErrorAction SilentlyContinue

      ## Step 2.7: Snapshot source (strip .git/.github/artifacts, zip & expand into artifacts folder)
      - name: Snapshot source after changes
        shell: pwsh
        run: |
          $src = $pwd.Path
          $zip = Join-Path $env:RUNNER_TEMP "source_after_changes_${env:APP_NAME}.zip"
          $dst = Join-Path $pwd "artifacts\source_after_changes_${env:APP_NAME}"
          New-Item -ItemType Directory -Force -Path $dst | Out-Null
          # ⚠️ Keep .git deleted here so snapshot is portable — we’ll re-checkout before commit
          Remove-Item -Recurse -Force "$src\.git","$src\.github","$src\artifacts" -ErrorAction SilentlyContinue
          Compress-Archive -Path "$src\*" -DestinationPath $zip -Force
          Expand-Archive -Path $zip -DestinationPath $dst -Force

      ## Step 2.8: Upload snapshot artifact
      - name: Upload source_after_changes
        uses: actions/upload-artifact@v4
        with:
          name: source_after_changes_${{ env.APP_NAME }}
          path: artifacts/source_after_changes_${{ env.APP_NAME }}

      ## Step 2.9: Detect .sln file in snapshot (needed for restore/build/test)
      - name: Detect solution
        shell: pwsh
        run: |
          $sln = Get-ChildItem -Path artifacts/source_after_changes_${env:APP_NAME} -Recurse -Filter *.sln | Select-Object -First 1
          if (-not $sln) { throw "No .sln found in snapshot" }
          "SLN_PATH=$($sln.FullName)" | Out-File -FilePath $env:GITHUB_ENV -Append

      ## Step 2.10: Restore NuGet packages
      - name: Restore
        shell: pwsh
        run: dotnet restore "$env:SLN_PATH"

      ## Step 2.11: Build in Release mode
      - name: Build
        shell: pwsh
        run: dotnet build --no-restore -c Release "$env:SLN_PATH"

      ## Step 2.12: Run unit tests
      - name: Test
        shell: pwsh
        run: dotnet test --no-build -c Release "$env:SLN_PATH"

      ## Step 2.13a: Re-checkout repo to restore .git before push
      - name: Checkout repo again for reset
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      ## Step 2.13b: Reset BASE_BRANCH to the snapshot contents and push
      - name: Reset branch with snapshot
        shell: pwsh
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git checkout -B "${env:BASE_BRANCH}"
          git rm -rf . || true
          Copy-Item -Path "artifacts/source_after_changes_${env:APP_NAME}\*" -Destination "." -Recurse -Force
          Remove-Item -Recurse -Force "artifacts/source_after_changes_${env:APP_NAME}"
          git add -A
          $commitMsg = git log -1 --pretty=%B origin/main
          git commit -m "Regenerated ${env:BASE_BRANCH}: $commitMsg" || echo "No changes to commit"
          git push origin HEAD:${env:BASE_BRANCH} --force
