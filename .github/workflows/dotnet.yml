name: .NET (Windows • remove via feeder • safe rename • source snapshot)

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      selections:
        description: "Comma-separated highest→lowest to remove (e.g., 6,5,4)"
        required: false
        default: "6,5,4,3,2,1"
      delay_ms:
        description: "Delay (ms) between lines sent to the apps"
        required: false
        default: "1000"
      app_name:
        description: "New application name for the rename tool (letters only, e.g., FreeCICD)"
        required: false
        default: "FreeCICD"

permissions:
  contents: write

#---------------------------------------------------------
# Global environment variables
#---------------------------------------------------------
env:
  SELECTIONS: ${{ github.event.inputs.selections || '6,5,4,3,2,1' }}
  DELAY_MS:  ${{ github.event.inputs.delay_ms    || '1000' }}
  APP_NAME:  ${{ github.event.inputs.app_name    || 'FreeCICD' }}

  REMOVE_EXE: '.\Remove Modules from FreeCRM.exe'
  RENAME_EXE: '.\Rename FreeCRM.exe'
  FEEDER_EXE: '.\tools\StdInFeeder\out\StdInFeeder.exe'

  BASE_BRANCH: FreeCICD_base

jobs:
  #---------------------------------------------------------
  # Job 1: Build feeder exe
  #---------------------------------------------------------
  feeder:
    name: Build feeder
    runs-on: windows-latest
    steps:
      - name: Setup .NET SDK 8
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Create feeder project (with kill-on support)
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path tools\StdInFeeder | Out-Null

          $code = @'
          using System;
          using System.Diagnostics;
          using System.IO;
          using System.Text;
          using System.Threading.Tasks;

          class Program
          {
              static int Main(string[] args)
              {
                  string exe = null;
                  string inputPath = null;
                  int delay = 500;

                  string killOn = null;
                  int killDelay = 200;
                  bool killTriggered = false;

                  for (int i = 0; i < args.Length; i++)
                  {
                      switch (args[i])
                      {
                          case "--exe":        exe = args[++i]; break;
                          case "--input":      inputPath = args[++i]; break;
                          case "--delay":      delay = int.Parse(args[++i]); break;
                          case "--kill-on":    killOn = args[++i]; break;
                          case "--kill-delay": killDelay = int.Parse(args[++i]); break;
                      }
                  }

                  if (string.IsNullOrWhiteSpace(exe) || !File.Exists(exe))
                  {
                      Console.Error.WriteLine($"Target exe not found: {exe}");
                      return 2;
                  }
                  if (string.IsNullOrWhiteSpace(inputPath) || !File.Exists(inputPath))
                  {
                      Console.Error.WriteLine($"Input file not found: {inputPath}");
                      return 3;
                  }

                  var psi = new ProcessStartInfo
                  {
                      FileName = exe,
                      UseShellExecute = false,
                      RedirectStandardInput = true,
                      RedirectStandardOutput = true,
                      RedirectStandardError = true,
                      CreateNoWindow = true
                  };

                  using var p = new Process { StartInfo = psi };

                  p.OutputDataReceived += (_, e) =>
                  {
                      if (e.Data != null)
                      {
                          Console.WriteLine(e.Data);
                          if (!string.IsNullOrEmpty(killOn) &&
                              e.Data.IndexOf(killOn, StringComparison.OrdinalIgnoreCase) >= 0 &&
                              !killTriggered)
                          {
                              killTriggered = true;
                              _ = Task.Run(() =>
                              {
                                  try
                                  {
                                      System.Threading.Thread.Sleep(killDelay);
                                      if (!p.HasExited)
                                      {
                                          try { p.CloseMainWindow(); } catch { }
                                          if (!p.HasExited) p.Kill(true);
                                      }
                                  }
                                  catch { }
                              });
                          }
                      }
                  };
                  p.ErrorDataReceived += (_, e) => { if (e.Data != null) Console.Error.WriteLine(e.Data); };

                  if (!p.Start()) return 4;
                  p.BeginOutputReadLine();
                  p.BeginErrorReadLine();

                  foreach (var line in File.ReadAllLines(inputPath, Encoding.ASCII))
                  {
                      p.StandardInput.WriteLine(line);
                      p.StandardInput.Flush();
                      System.Threading.Thread.Sleep(delay);
                  }
                  p.StandardInput.Close();

                  p.WaitForExit();

                  return killTriggered ? 0 : p.ExitCode;
              }
          }
          '@
          Set-Content -Path tools\StdInFeeder\Program.cs -Value $code -Encoding UTF8

          $proj = @'
          <Project Sdk="Microsoft.NET.Sdk">
            <PropertyGroup>
              <OutputType>Exe</OutputType>
              <TargetFramework>net8.0</TargetFramework>
              <PublishSingleFile>true</PublishSingleFile>
              <RuntimeIdentifier>win-x64</RuntimeIdentifier>
              <SelfContained>false</SelfContained>
            </PropertyGroup>
          </Project>
          '@
          Set-Content -Path tools\StdInFeeder\StdInFeeder.csproj -Value $proj -Encoding UTF8

      - name: Publish feeder
        shell: pwsh
        run: |
          dotnet publish tools\StdInFeeder -c Release -o tools\StdInFeeder\out

      - name: Upload feeder artifact
        uses: actions/upload-artifact@v4
        with:
          name: stdin_feeder
          path: tools/StdInFeeder/out

  #---------------------------------------------------------
  # Job 2: Modify repo & snapshot
  #---------------------------------------------------------
  modify:
    name: Modify repo & snapshot
    runs-on: windows-latest
    needs: feeder
    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET 9 & 8
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            9.0.x
            8.0.x

      - name: Download feeder artifact
        uses: actions/download-artifact@v4
        with:
          name: stdin_feeder
          path: tools/StdInFeeder/out

      - name: Run remove modules helper
        shell: pwsh
        run: |
          $exe = $env:REMOVE_EXE
          $targets = $env:SELECTIONS -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ -match '^\d+$' } | ForEach-Object { [int]$_ } | Sort-Object -Descending
          foreach ($n in $targets) {
            Set-Content -Path input.txt -Value @("$n","x") -Encoding ASCII
            & $env:FEEDER_EXE --exe "$exe" --input "input.txt" --delay $env:DELAY_MS
            if ($LASTEXITCODE -ne 0) { throw "Remove run failed for selection $n (exit $LASTEXITCODE)" }
            Remove-Item input.txt -Force
          }

      - name: Run rename helper
        shell: pwsh
        run: |
          $exe = $env:RENAME_EXE
          if ($env:APP_NAME -notmatch '^[A-Za-z]+$') { throw "APP_NAME '$env:APP_NAME' is invalid." }
          Set-Content -Path rename.txt -Value @($env:APP_NAME) -Encoding ASCII
          & $env:FEEDER_EXE --exe "$exe" --input "rename.txt" --delay 500 --kill-on "press any key" --kill-delay 200
          if ($LASTEXITCODE -ne 0) { throw "Rename run failed (exit $LASTEXITCODE)" }
          Remove-Item rename.txt -Force

      - name: Clean up helper tools
        shell: pwsh
        run: |
          Remove-Item -Recurse -Force "tools\StdInFeeder" -ErrorAction SilentlyContinue
          Remove-Item "$env:REMOVE_EXE" -ErrorAction SilentlyContinue
          Remove-Item "$env:RENAME_EXE" -ErrorAction SilentlyContinue

      - name: Snapshot source after changes
        shell: pwsh
        run: |
          $src = $pwd.Path
          $zip = Join-Path $env:RUNNER_TEMP "source_after_changes.zip"
          $dst = Join-Path $pwd "artifacts\source_after_changes"
          New-Item -ItemType Directory -Force -Path $dst | Out-Null
          Remove-Item -Recurse -Force "$src\.git","$src\.github","$src\artifacts" -ErrorAction SilentlyContinue
          Compress-Archive -Path "$src\*" -DestinationPath $zip -Force
          Expand-Archive -Path $zip -DestinationPath $dst -Force

      - name: Upload source_after_changes
        uses: actions/upload-artifact@v4
        with:
          name: source_after_changes
          path: artifacts/source_after_changes

  #---------------------------------------------------------
  # Job 3: Build & test snapshot
  #---------------------------------------------------------
  build:
    name: Build & test snapshot
    runs-on: windows-latest
    needs: modify
    steps:
      - name: Download source_after_changes
        uses: actions/download-artifact@v4
        with:
          name: source_after_changes
          path: _src

      - name: Detect solution
        shell: pwsh
        run: |
          $sln = Get-ChildItem -Path _src -Recurse -Filter *.sln | Select-Object -First 1
          if (-not $sln) { throw "No .sln found in snapshot" }
          "SLN_PATH=$($sln.FullName)" | Out-File -FilePath $env:GITHUB_ENV -Append

      - name: Setup .NET 9 & 8
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            9.0.x
            8.0.x

      - name: Restore
        shell: pwsh
        run: dotnet restore "$env:SLN_PATH"

      - name: Build
        shell: pwsh
        run: dotnet build --no-restore -c Release "$env:SLN_PATH"

      - name: Test
        shell: pwsh
        run: dotnet test --no-build -c Release "$env:SLN_PATH"

  #---------------------------------------------------------
  # Job 4: Update BASE_BRANCH branch
  #---------------------------------------------------------
  update-branch:
    name: Replace BASE_BRANCH branch with new snapshot
    runs-on: windows-latest
    needs: modify
    steps:
      - name: Checkout repo (default branch)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download source_after_changes
        uses: actions/download-artifact@v4
        with:
          name: source_after_changes
          path: ${{ runner.temp }}/_consume

      - name: Reset branch with snapshot
        shell: pwsh
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git checkout -B "${env:BASE_BRANCH}"
          git rm -rf . || true
          Copy-Item -Path "$env:RUNNER_TEMP\_consume\*" -Destination "." -Recurse -Force
          Remove-Item -Recurse -Force "$env:RUNNER_TEMP\_consume"
          git add -A
          $commitMsg = git log -1 --pretty=%B origin/main
          git commit -m "Regenerated BASE_BRANCH: $commitMsg" || echo "No changes to commit"
          git push origin HEAD:${env:BASE_BRANCH} --force
