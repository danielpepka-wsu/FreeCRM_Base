name: .NET (Windows + Remove Modules)

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      selections:
        description: "Comma-separated highest→lowest selections to remove (e.g., 6,5,4)"
        required: false
        default: "6,5,4,3,2,1"

jobs:
  build:
    runs-on: windows-latest

    env:
      # Set your EXE paths (adjust these to where your build drops them)
      REMOVE_EXE: .\RemoveModulesFromFreeCRM.exe
      RENAME_EXE: .\RenameFreeCRM.exe
      # This is only populated on manual dispatch; we'll handle defaulting in the step
      SELECTIONS: ${{ github.event.inputs.selections }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.x

      - name: Restore
        shell: pwsh
        run: dotnet restore

      - name: Build
        shell: pwsh
        run: dotnet build --no-restore

      - name: Test
        shell: pwsh
        run: dotnet test --no-build --verbosity normal

      # Optional: run rename tool once before removals
      # - name: Run rename utility (optional)
      #   shell: pwsh
      #   run: |
      #     if (Test-Path $env:RENAME_EXE) {
      #       Write-Host "Running $env:RENAME_EXE ..."
      #       & $env:RENAME_EXE
      #       if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }
      #     } else {
      #       Write-Host "Rename EXE not found at $env:RENAME_EXE — skipping."
      #     }

      - name: Remove modules (highest → lowest) with STDIN file
        shell: pwsh
        run: |
          $exe = $env:REMOVE_EXE
          if (-not (Test-Path $exe)) { throw "Remove utility not found at: $exe" }

          # Use dispatch input if provided; otherwise default for push/PR
          $selections = $env:SELECTIONS
          if ([string]::IsNullOrWhiteSpace($selections)) { $selections = "6,5,4,3,2,1" }

          $targets =
            $selections -split ',' |
            ForEach-Object { $_.Trim() } |
            Where-Object { $_ -match '^\d+$' } |
            ForEach-Object { [int]$_ } |
            Sort-Object -Descending  # enforce highest→lowest

          if (-not $targets) { throw "No valid numeric selections in: '$selections'" }

          Write-Host "Selections to remove (highest→lowest): $($targets -join ', ')"

          foreach ($n in $targets) {
            Write-Host "`n=== $exe with selection $n, then 'x' ==="

            # Build file content with CRLF line endings: "<n>\r\nx\r\n"
            $inputText = "$n`r`nx`r`n"
            Set-Content -Path input.txt -Value $inputText -NoNewline -Encoding ascii

            # Feed the file into STDIN
            & $exe < input.txt
            if ($LASTEXITCODE -ne 0) {
              throw "Run failed for selection $n (exit $LASTEXITCODE)"
            }

            # Clean up and brief pause
            Remove-Item input.txt -Force -ErrorAction SilentlyContinue
            Start-Sleep -Seconds 1
          }

          Write-Host "`nAll removals completed."
