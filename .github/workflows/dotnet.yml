name: .NET (Windows • multi-project remove via feeder • safe rename • source snapshot • auto-merge to app branch)

on:
  push:
    branches: [ "main" ]      # Trigger when main branch is updated
  pull_request:
    branches: [ "main" ]      # Also trigger on PRs targeting main
  workflow_dispatch:          # Manual trigger (with overrides allowed)
    inputs:
      selections:
        description: "Comma-separated highest→lowest to remove (overrides matrix)"
        required: false
        default: ""
      delay_ms:
        description: "Delay (ms) between lines sent to the apps"
        required: false
        default: "1000"
      app_name:
        description: "New application name for the rename tool (overrides matrix)"
        required: false
        default: ""

permissions:
  contents: write   # Required so we can push commits, create branches, and tag snapshots

#---------------------------------------------------------
# Job 1: Build feeder exe (runs once, shared by all projects)
#---------------------------------------------------------
jobs:
  feeder:
    name: Job 1 • Build feeder
    runs-on: windows-latest
    steps:
      ## Step 1.1: Setup .NET SDK 8 (for building helper exe)
      - name: Setup .NET SDK 8
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      ## Step 1.2: Create feeder project (with kill-on support)
      # This tool simulates keyboard input into console apps, with optional "kill-on" trigger.
      - name: Create feeder project
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path tools\StdInFeeder | Out-Null
          $code = @'
          using System;
          using System.Diagnostics;
          using System.IO;
          using System.Text;
          using System.Threading.Tasks;
          class Program {
              static int Main(string[] args) {
                  string exe = null;
                  string inputPath = null;
                  int delay = 500;
                  string killOn = null;
                  int killDelay = 200;
                  bool killTriggered = false;
                  for (int i = 0; i < args.Length; i++) {
                      switch (args[i]) {
                          case "--exe":        exe = args[++i]; break;
                          case "--input":      inputPath = args[++i]; break;
                          case "--delay":      delay = int.Parse(args[++i]); break;
                          case "--kill-on":    killOn = args[++i]; break;
                          case "--kill-delay": killDelay = int.Parse(args[++i]); break;
                      }
                  }
                  if (string.IsNullOrWhiteSpace(exe) || !File.Exists(exe)) {
                      Console.Error.WriteLine($"Target exe not found: {exe}"); return 2;
                  }
                  if (string.IsNullOrWhiteSpace(inputPath) || !File.Exists(inputPath)) {
                      Console.Error.WriteLine($"Input file not found: {inputPath}"); return 3;
                  }
                  var psi = new ProcessStartInfo {
                      FileName = exe,
                      UseShellExecute = false,
                      RedirectStandardInput = true,
                      RedirectStandardOutput = true,
                      RedirectStandardError = true,
                      CreateNoWindow = true
                  };
                  using var p = new Process { StartInfo = psi };
                  p.OutputDataReceived += (_, e) => {
                      if (e.Data != null) {
                          Console.WriteLine(e.Data);
                          if (!string.IsNullOrEmpty(killOn) &&
                              e.Data.IndexOf(killOn, StringComparison.OrdinalIgnoreCase) >= 0 &&
                              !killTriggered) {
                              killTriggered = true;
                              _ = Task.Run(() => {
                                  try {
                                      System.Threading.Thread.Sleep(killDelay);
                                      if (!p.HasExited) {
                                          try { p.CloseMainWindow(); } catch { }
                                          if (!p.HasExited) p.Kill(true);
                                      }
                                  } catch { }
                              });
                          }
                      }
                  };
                  p.ErrorDataReceived += (_, e) => { if (e.Data != null) Console.Error.WriteLine(e.Data); };
                  if (!p.Start()) return 4;
                  p.BeginOutputReadLine();
                  p.BeginErrorReadLine();
                  foreach (var line in File.ReadAllLines(inputPath, Encoding.ASCII)) {
                      p.StandardInput.WriteLine(line);
                      p.StandardInput.Flush();
                      System.Threading.Thread.Sleep(delay);
                  }
                  p.StandardInput.Close();
                  p.WaitForExit();
                  return killTriggered ? 0 : p.ExitCode;
              }
          }
          '@
          Set-Content -Path tools\StdInFeeder\Program.cs -Value $code -Encoding UTF8

          # Minimal csproj file that builds as single-file exe
          $proj = @'
          <Project Sdk="Microsoft.NET.Sdk">
            <PropertyGroup>
              <OutputType>Exe</OutputType>
              <TargetFramework>net8.0</TargetFramework>
              <PublishSingleFile>true</PublishSingleFile>
              <RuntimeIdentifier>win-x64</RuntimeIdentifier>
              <SelfContained>false</SelfContained>
            </PropertyGroup>
          </Project>
          '@
          Set-Content -Path tools\StdInFeeder\StdInFeeder.csproj -Value $proj -Encoding UTF8

      ## Step 1.3: Publish feeder (compile and output binary)
      - name: Publish feeder
        shell: pwsh
        run: |
          dotnet publish tools\StdInFeeder -c Release -o tools\StdInFeeder\out

      ## Step 1.4: Upload feeder artifact (so other jobs can reuse)
      - name: Upload feeder artifact
        uses: actions/upload-artifact@v4
        with:
          name: stdin_feeder
          path: tools/StdInFeeder/out

#---------------------------------------------------------
# Job 2 (matrix): Process each project
#---------------------------------------------------------
  project:
    name: Job 2 • Process ${{ matrix.project.name }}
    runs-on: windows-latest
    needs: feeder

    strategy:
      fail-fast: false
      matrix:
        project:
          - name: FreeCICD
            branch: FreeCICD_base
            selections: "6,5,4,3,2,1"
          - name: FreeLLM
            branch: FreeLLM_base
            selections: "7,6,5,4,3,2,1"

    env:
      SELECTIONS: ${{ github.event.inputs.selections || matrix.project.selections }}
      APP_NAME:  ${{ github.event.inputs.app_name || matrix.project.name }}
      BASE_BRANCH: ${{ matrix.project.branch }}
      DELAY_MS:  ${{ github.event.inputs.delay_ms || '1000' }}
      REMOVE_EXE: '.\Remove Modules from FreeCRM.exe'
      RENAME_EXE: '.\Rename FreeCRM.exe'
      FEEDER_EXE: '.\tools\StdInFeeder\out\StdInFeeder.exe'

    steps:
      ## Step 2.1: Checkout repo (full depth for main + branches)
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      ## Step 2.2: Setup .NET 9 & 8 SDKs (so both are available)
      - name: Setup .NET 9 & 8
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            9.0.x
            8.0.x

      ## Step 2.3: Download feeder artifact (from Job 1)
      - name: Download feeder artifact
        uses: actions/download-artifact@v4
        with:
          name: stdin_feeder
          path: tools/StdInFeeder/out

      ## Step 2.4: Run remove modules helper (loop through list)
      - name: Run remove modules helper
        shell: pwsh
        run: |
          $exe = $env:REMOVE_EXE
          $targets = $env:SELECTIONS -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ -match '^\d+$' } | ForEach-Object { [int]$_ } | Sort-Object -Descending
          foreach ($n in $targets) {
            Set-Content -Path input.txt -Value @("$n","x") -Encoding ASCII
            & $env:FEEDER_EXE --exe "$exe" --input "input.txt" --delay $env:DELAY_MS
            if ($LASTEXITCODE -ne 0) { throw "Remove run failed for selection $n (exit $LASTEXITCODE)" }
            Remove-Item input.txt -Force
          }

      ## Step 2.5: Run rename helper (feeds in new app name)
      - name: Run rename helper
        shell: pwsh
        run: |
          $exe = $env:RENAME_EXE
          if ($env:APP_NAME -notmatch '^[A-Za-z]+$') { throw "APP_NAME '$env:APP_NAME' is invalid." }
          Set-Content -Path rename.txt -Value @($env:APP_NAME) -Encoding ASCII
          & $env:FEEDER_EXE --exe "$exe" --input "rename.txt" --delay 500 --kill-on "press any key" --kill-delay 200
          if ($LASTEXITCODE -ne 0) { throw "Rename run failed (exit $LASTEXITCODE)" }
          Remove-Item rename.txt -Force

      ## Step 2.6: Clean up helper tools (remove EXEs + feeder source)
      - name: Clean up helper tools
        shell: pwsh
        run: |
          Remove-Item -Recurse -Force "tools\StdInFeeder" -ErrorAction SilentlyContinue
          Remove-Item "$env:REMOVE_EXE" -ErrorAction SilentlyContinue
          Remove-Item "$env:RENAME_EXE" -ErrorAction SilentlyContinue

      ## Step 2.7: Snapshot source after changes
      - name: Snapshot source after changes
        shell: pwsh
        run: |
          $src = $pwd.Path
          $zip = Join-Path $env:RUNNER_TEMP "source_after_changes_${env:APP_NAME}.zip"
          $dst = Join-Path $pwd "artifacts\source_after_changes_${env:APP_NAME}"
          New-Item -ItemType Directory -Force -Path $dst | Out-Null
          Remove-Item -Recurse -Force "$src\.git","$src\.github","$src\artifacts" -ErrorAction SilentlyContinue
          Compress-Archive -Path "$src\*" -DestinationPath $zip -Force
          Expand-Archive -Path $zip -DestinationPath $dst -Force

      ## Step 2.8: Upload source_after_changes artifact
      - name: Upload source_after_changes
        uses: actions/upload-artifact@v4
        with:
          name: source_after_changes_${{ env.APP_NAME }}
          path: artifacts/source_after_changes_${{ env.APP_NAME }}

      ## Step 2.9: Detect solution file (.sln) inside snapshot
      - name: Detect solution
        shell: pwsh
        run: |
          $sln = Get-ChildItem -Path artifacts/source_after_changes_${env:APP_NAME} -Recurse -Filter *.sln | Select-Object -First 1
          if (-not $sln) { throw "No .sln found in snapshot" }
          "SLN_PATH=$($sln.FullName)" | Out-File -FilePath $env:GITHUB_ENV -Append

      ## Step 2.10: Restore NuGet packages
      - name: Restore
        shell: pwsh
        run: dotnet restore "$env:SLN_PATH"

      ## Step 2.11: Build project
      - name: Build
        shell: pwsh
        run: dotnet build --no-restore -c Release "$env:SLN_PATH"

      ## Step 2.12: Run tests
      - name: Test
        shell: pwsh
        run: dotnet test --no-build -c Release "$env:SLN_PATH"

      ## Step 2.13a: Checkout again for clean git context
      - name: Checkout repo again (for git context)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      ## Step 2.13b: Reset BASE_BRANCH with snapshot, commit with latest main message
      - name: Reset base branch with snapshot
        id: reset-base
        shell: pwsh
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git checkout -B "${env:BASE_BRANCH}"
          git rm -rf . || true
          Copy-Item -Path "artifacts/source_after_changes_${env:APP_NAME}\*" -Destination "." -Recurse -Force
          Remove-Item -Recurse -Force "artifacts/source_after_changes_${env:APP_NAME}"
          git add -A
          $commitMsg = git log -1 --pretty=%B origin/main
          git commit -m "Regenerated ${env:BASE_BRANCH}: $commitMsg" || echo "No changes to commit"
          git push origin HEAD:${env:BASE_BRANCH} --force
          echo "commitMsg=$commitMsg" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      ## Step 2.13c: Tag snapshot for rollback
      - name: Tag snapshot release
        shell: pwsh
        run: |
          $tagName = "snapshot/${env:APP_NAME}/$(Get-Date -Format yyyyMMdd-HHmmss)"
          git tag $tagName
          git push origin $tagName
          echo "Tagged snapshot as $tagName"

      ## Step 2.14: Ensure app branch exists (create if missing)
      - name: Ensure app branch exists
        id: ensure-branch
        shell: pwsh
        run: |
          $branch = "${env:APP_NAME}"
          $exists = git ls-remote --heads origin $branch
          if (-not $exists) {
            Write-Host "Branch $branch does not exist. Creating it..."
            git checkout -B $branch
            git push origin HEAD:$branch
            echo "created=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          } else {
            echo "created=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }

      ## Step 2.15: Open PR from BASE_BRANCH → APP_NAME if app branch exists
      - name: Suggest merge into app branch
        if: steps.ensure-branch.outputs.created == 'false'
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          base: ${{ env.APP_NAME }}       # Target branch (app branch)
          head: ${{ env.BASE_BRANCH }}    # Source branch (base branch snapshot)
          title: "[AUTO] Sync: ${{ steps.reset-base.outputs.commitMsg }}"
          body: |
            This PR was automatically created by the workflow.

            - Latest commit from **origin/main**:
              ```
              ${{ steps.reset-base.outputs.commitMsg }}
              ```

            - Snapshot branch: `${{ env.BASE_BRANCH }}`
            - Target app branch: `${{ env.APP_NAME }}`

            Snapshot rollback tag was created for safety:
            ```
            snapshot/${{ env.APP_NAME }}/<timestamp>
            ```

            If no conflicts, this PR will be auto-merged.
          draft: false
          merge-method: squash
          auto-merge: true
